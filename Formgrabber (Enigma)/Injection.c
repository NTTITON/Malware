#include <Windows.h>
#include "C Runtime.h"
#include "Injection.h"

__declspec(naked) void GetImageBase()
{
	__asm
	{
			mov EAX, GetImageBase
			and eax, 0xFFFF0000
		find:
			cmp word ptr [ eax ], 0x5A4D
			je end
			sub eax, 0x00010000
			JMP find
         end:
		   ret

	}
}

VOID ProcessRelocations(PIMAGE_BASE_RELOCATION Relocs,  DWORD ImageBase,DWORD Delta, DWORD Size)
{
	PIMAGE_BASE_RELOCATION Reloc = Relocs;
	PIMAGE_FIXUP_ENTRY Fixup = 0;
	DWORD i = 0;
	while ((DWORD)Reloc - (DWORD)Relocs < Size)
	{
		if (!Reloc->SizeOfBlock)
		{
			break;
		}
		Fixup = (PIMAGE_FIXUP_ENTRY)((DWORD)Reloc + sizeof(IMAGE_BASE_RELOCATION));
		for (i = 0; i < (Reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) >> 1 ; i++, Fixup++)
		{
			DWORD dwPointerRVA = ((DWORD)Reloc->VirtualAddress + Fixup->Offset);

			if (Fixup->Offset != 0)
			{
				*(DWORD*)(ImageBase + dwPointerRVA) += Delta;
			}
		}
		Reloc = (PIMAGE_BASE_RELOCATION)((DWORD)Reloc + Reloc->SizeOfBlock);
	}
}

DWORD Inject(LPTHREAD_START_ROUTINE Function, HANDLE proc)
{
	DWORD Base = 0;
	HMODULE hModule = ((HMODULE(*)())GetImageBase)();
	PIMAGE_DOS_HEADER DOS = (PIMAGE_DOS_HEADER)hModule;
	PIMAGE_NT_HEADERS NT = (PIMAGE_NT_HEADERS)((DWORD)hModule + DOS->e_lfanew);
	DWORD ulSize = NT->OptionalHeader.SizeOfImage;
	LPVOID lpNewAddr = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,ulSize);
	if (lpNewAddr)
	{
		m_memcpy(lpNewAddr, hModule, ulSize);
		if ((Base = (DWORD)VirtualAllocEx(proc, NULL,ulSize, MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
		{
			DWORD RelRVA = NT->OptionalHeader.DataDirectory[5].VirtualAddress;
			DWORD RelSize = NT->OptionalHeader.DataDirectory[5].Size;
			ProcessRelocations((PIMAGE_BASE_RELOCATION)((DWORD)hModule + RelRVA), (DWORD)lpNewAddr, (DWORD)Base - (DWORD)hModule,  RelSize);
			if (WriteProcessMemory(proc, (LPVOID)Base, lpNewAddr, ulSize, 0))
			{
				Base += (DWORD)Function - (DWORD)hModule;
			}
		}

		HeapFree(GetProcessHeap(),0,lpNewAddr);
	}
	return Base;
}
