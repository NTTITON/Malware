#include <Windows.h>
#include "PE Tools.h"
#include "C Runtime.h"
#include <Shlwapi.h>

PPEB32 GetPEB()
{
	_asm MOV EAX,DWORD PTR FS:[30h]
}


DWORD GetModuleSize(HMODULE hModule)
{
	if (hModule)
	{
		PIMAGE_DOS_HEADER pDOS = (PIMAGE_DOS_HEADER)hModule;
		PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(pDOS->e_lfanew + (DWORD)hModule);
		if (pNT->Signature == IMAGE_NT_SIGNATURE && pDOS->e_magic == IMAGE_DOS_SIGNATURE)
		{
			return pNT->OptionalHeader.SizeOfImage;
		}
	}
	return 0;
}



BOOL Is64(HANDLE hProcess)
{
	LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress32((HMODULE)GetModuleBase32(L"kernel32.dll"),"IsWow64Process");
	BOOL Is64 = FALSE;

	if (fnIsWow64Process)
	{
		fnIsWow64Process(hProcess, &Is64);
	}
	return Is64;
}

void * GetProcAddress32( void * lvpBaseAddress, char * lpszProcName )
{
	if (lvpBaseAddress)
	{
		PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)((DWORD)lvpBaseAddress);
		PIMAGE_NT_HEADERS psNtHeader = (PIMAGE_NT_HEADERS)( pDos->e_lfanew + (DWORD)lvpBaseAddress );

		char * lpcModBase = (char *)lvpBaseAddress;
		PIMAGE_EXPORT_DIRECTORY psExportDir = (PIMAGE_EXPORT_DIRECTORY)( lpcModBase + 
			psNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress );

		int nNumberOfNames = psExportDir->NumberOfNames;
		unsigned long * lpulFunctions = 
			(unsigned long *)( lpcModBase + psExportDir->AddressOfFunctions );

		unsigned long * lpulNames = 
			(unsigned long *)( lpcModBase + psExportDir->AddressOfNames );

		unsigned short * lpusOrdinals = 
			(unsigned short *) ( lpcModBase + psExportDir->AddressOfNameOrdinals );
		int i;
		char * lpszFunctionName;
		for( i = 0; i < nNumberOfNames; i++ ) {
			lpszFunctionName = ((__int8 *)lpulNames[i]) + (int)lvpBaseAddress;



			if( StrCmpNIA( lpszFunctionName, lpszProcName , strlen(lpszProcName)) == 0 ) 
			{

				DWORD Offset = lpulFunctions[ lpusOrdinals[i] ];
				void* FunctionAddress = (void*)(Offset+(DWORD)lvpBaseAddress);

				if (Offset >= psNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress
					&& Offset < (psNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress +psNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size))
				{

				      return 0;
				}

				return FunctionAddress;
			}
		}
	}
	return NULL;
}


void* GetModuleBase32(wchar_t* szModule)
{
	PPEB32 Peb = GetPEB();
	PPEB_LDR_DATA Ldr = Peb->Ldr;
	PLDR_DATA_TABLE_ENTRY DataEntryStart = (PLDR_DATA_TABLE_ENTRY)Ldr->InLoadOrderModuleList.Flink;
	PLDR_DATA_TABLE_ENTRY DataCurrent = DataEntryStart;

	if (szModule == NULL)
		return DataCurrent->DllBase;
	do
	{
		if (!StrCmpNIW(DataCurrent->BaseDllName.Buffer, szModule, DataCurrent->BaseDllName.Length))
		{
			return DataCurrent->DllBase;
		}

		DataCurrent = (PLDR_DATA_TABLE_ENTRY)DataCurrent->InLoadOrderLinks.Flink;
	}while(DataEntryStart != DataCurrent && DataCurrent && DataCurrent->BaseDllName.Buffer);


	return NULL;
}
