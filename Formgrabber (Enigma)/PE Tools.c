#include <Windows.h>
#include "PE Tools.h"
#include "C Runtime.h"
#include <Shlwapi.h>

DWORD GetModuleSize(HMODULE hModule)
{
	if (hModule)
	{
		PIMAGE_DOS_HEADER pDOS = (PIMAGE_DOS_HEADER)hModule;
		PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(pDOS->e_lfanew + (DWORD)hModule);
		if (pNT->Signature == IMAGE_NT_SIGNATURE && pDOS->e_magic == IMAGE_DOS_SIGNATURE)
		{
			return pNT->OptionalHeader.SizeOfImage;
		}
	}
	return 0;
}



BOOL Is64(HANDLE hProcess)
{
	LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress32((HMODULE)GetModuleBase32(L"kernel32.dll"),"IsWow64Process");
	BOOL Is64 = FALSE;

	if (fnIsWow64Process)
	{
		fnIsWow64Process(hProcess, &Is64);
	}
	return Is64;
}

PPEB32 GetPEB()
{
	_asm MOV EAX,DWORD PTR FS:[30h]
}


void * GetProcAddress32( void * lvpBaseAddress, char * lpszProcName )
{

	if (lvpBaseAddress)
	{
		PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)((DWORD)lvpBaseAddress);
		PIMAGE_NT_HEADERS psNtHeader = (PIMAGE_NT_HEADERS)( pDos->e_lfanew + (DWORD)lvpBaseAddress );

		char * lpcModBase = (char *)lvpBaseAddress;
		PIMAGE_EXPORT_DIRECTORY psExportDir = (PIMAGE_EXPORT_DIRECTORY)( lpcModBase + 
			psNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress );

		int nNumberOfNames = psExportDir->NumberOfNames;
		unsigned long * lpulFunctions = 
			(unsigned long *)( lpcModBase + psExportDir->AddressOfFunctions );

		unsigned long * lpulNames = 
			(unsigned long *)( lpcModBase + psExportDir->AddressOfNames );

		unsigned short * lpusOrdinals = 
			(unsigned short *) ( lpcModBase + psExportDir->AddressOfNameOrdinals );



		int i;
		char * lpszFunctionName;




		for( i = 0; i < nNumberOfNames; i++ ) {
			lpszFunctionName = ((__int8 *)lpulNames[i]) + (int)lvpBaseAddress;



			if( StrCmpNIA( lpszFunctionName, lpszProcName , strlen(lpszProcName)) == 0 ) 
			{

				DWORD Offset = lpulFunctions[ lpusOrdinals[i] ];
				void* FunctionAddress = (void*)(Offset+(DWORD)lvpBaseAddress);

				if (Offset >= psNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress
					&& Offset < (psNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress +psNtHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size))
				{

					DWORD ulName = strlen((char*)((DWORD)lvpBaseAddress + Offset))+1;
					char *forward_lib = (char*)VirtualAlloc(NULL,ulName,MEM_COMMIT|MEM_RESERVE,0x40);

					if (forward_lib)
					{
						char* forward_name = forward_lib;
						RtlSecureZeroMemory(forward_lib,ulName);
						m_memcpy(forward_lib, (char*)((DWORD)lvpBaseAddress + Offset), ulName-1);

						while(*++forward_name != '.');

						*forward_name++ = 0;

						lvpBaseAddress = LoadLibraryA(forward_lib);
						if (lvpBaseAddress)
						{
							FunctionAddress = GetProcAddress32(lvpBaseAddress, forward_name);
						}
						else
							FunctionAddress = NULL;
						VirtualFree(forward_lib,0,MEM_RELEASE);
					}
				}

				return FunctionAddress;
			}
		}
	}
	return NULL;
}


void* GetModuleBase32(wchar_t* szModule)
{
	PPEB32 Peb = GetPEB();
	PPEB_LDR_DATA Ldr = Peb->Ldr;
	PLDR_DATA_TABLE_ENTRY DataEntryStart = (PLDR_DATA_TABLE_ENTRY)Ldr->InLoadOrderModuleList.Flink;
	PLDR_DATA_TABLE_ENTRY DataCurrent = DataEntryStart;

	if (szModule == NULL)
		return DataCurrent->DllBase;
	do
	{
		if (!StrCmpNIW(DataCurrent->BaseDllName.Buffer, szModule, DataCurrent->BaseDllName.Length))
		{
			return DataCurrent->DllBase;
		}

		DataCurrent = (PLDR_DATA_TABLE_ENTRY)DataCurrent->InLoadOrderLinks.Flink;
	}while(DataEntryStart != DataCurrent && DataCurrent && DataCurrent->BaseDllName.Buffer);


	return NULL;
}