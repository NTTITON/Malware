#include <Windows.h>
#include <stdio.h>
#include "Heavens Gate.h"



__declspec(naked) void* memcpy64(unsigned long long Dst, unsigned long long Src, unsigned long len)
{
	__asm
	{
		push ebp
			mov ebp, esp
			push esi
			push edi
			X64_Start()
			EMIT(0x67) EMIT(0x48) EMIT(0x8B) EMIT(0x75) EMIT(0x10) //mov rsi, qword ptr[ebp+16]
			EMIT(0x67) EMIT(0x48) EMIT(0x8B) EMIT(0x7D) EMIT(0x08) //mov rdi, qword ptr[ebp+8]
			EMIT(0x67) EMIT(0x8B) EMIT(0x4D) EMIT(0x18) //mov ecx, dword ptr [ebp+24]
			EMIT(0x8a) EMIT(0x06) //mov al, byte ptr[rsi]
			EMIT(0x88) EMIT(0x07) //mov byte ptr[rdi], al
			EMIT(0x48) EMIT(0xFF) EMIT(0xC6) //inc rsi
			EMIT(0x48) EMIT(0xFF) EMIT(0xC7) //inc rdi
			EMIT(0xE2) EMIT(0xF4) //loop e (mov al, byte ptr[rsi])
			X64_End()
			pop edi
			pop esi
			mov esp, ebp
			pop ebp
			ret
	}
}



__declspec(naked) void GetPEB64(PEB64* out)
{
	__asm
	{
		    push ebp
			mov ebp, esp
			sub esp, 8
			X64_Start()
			EMIT(0x65) EMIT(0x48) EMIT(0x8B) EMIT(0x04) EMIT(0x25) EMIT (0x60) EMIT(0x00) EMIT(0X00) EMIT(0X00) //mov rax, gs:[0x60]
			EMIT(0x50) //push rax
			EMIT(0x67) EMIT(0x8F) EMIT(0x45) EMIT(0xF8) //pop qword ptr[ebp-8]
			X64_End()	
			push 32 //dword
			push [ebp-0x04] //qword
		    push [ebp-0x08]
		    push 0
			push [ebp+0x08]  //qword
		    call memcpy64
			add esp, 20
			mov esp, ebp
			pop ebp
			ret
	}
}




__declspec(naked) int m_memcmp(void* Srcone, void*srcTwo, int len)
{
	__asm
	{
		push esi
			push edi
			push ebx
			mov esi, [esp+20]
		mov ecx, [esp+24]
		mov edi, [esp+16]
		mov ebx, 1
Compare:
		mov al, byte ptr[edi]
		cmp al, byte ptr[esi]
		jne NotEqual
			inc edi
			inc esi
			dec ecx
			jnz Compare
			mov ebx, 0
NotEqual:
		mov eax, ebx
			pop ebx
			pop edi
			pop esi
			ret
	}
}


__declspec(naked) unsigned long GetImageBase()
{
	__asm
	{
		mov eax, GetImageBase
			and eax, 0xFFFF0000
Find:
		cmp word ptr [eax], 0x5A4D
			je End
			sub eax, 0x00010000
			jmp Find
End:
		ret

	}
}

unsigned long long GetModuleHandle64(wchar_t* ModuleName)
{
	unsigned long long Current = 0;
	unsigned long long ulModule = 0;


	wchar_t szBuffer[512] = {0};

	PEB64 Peb64 = {0};
	LDR64 Ldr64 = {0};
	LDR_DATA_TABLE_ENTRY64 LdrEntry64 = {0};

	GetPEB64(&Peb64);

	if(Peb64.ImageBaseAddress == (unsigned long long)GetModuleHandle(0)/*GetImageBase()*/)
	{
		memcpy64((unsigned long long)&Ldr64, Peb64.Ldr, sizeof(LDR64));
		memcpy64((unsigned long long)&LdrEntry64, Ldr64.InLoadOrderModuleList.Flink, sizeof(LDR_DATA_TABLE_ENTRY64));

		do
		{

			Current = LdrEntry64.InLoadOrderLinks.Flink;

			if (Current == Peb64.Ldr + 0x10)
				break;

			memcpy64((unsigned long long)&LdrEntry64, LdrEntry64.InLoadOrderLinks.Flink, sizeof(LDR_DATA_TABLE_ENTRY64));
			memcpy64((unsigned long long)szBuffer, LdrEntry64.BaseDllName.Buffer, LdrEntry64.BaseDllName.Length);



			if (!m_memcmp(ModuleName, szBuffer, LdrEntry64.BaseDllName.Length))
			{
				ulModule = LdrEntry64.DllBase;
				break;
			}
		}while(1);
	}
	return ulModule;
}



unsigned long long GetNextArgument(unsigned long * ulCurrentArg, unsigned long ulArgCount, unsigned long long *pulArgs)
{

	unsigned long long NextArg = 0;
	if (*ulCurrentArg < ulArgCount)
	{
		NextArg = pulArgs[(*ulCurrentArg)++];
	}
	return NextArg;
}


unsigned long CallFunction64(unsigned long long ulAddress, unsigned long ulOrdinal, unsigned long long * pulArgs, unsigned long ulArgCount, unsigned char ucType)
{

	unsigned long ulNtStatus = 0;
	unsigned long long StackArguments = 0;
	unsigned long long StackCount = 0;
	unsigned long ulCurrentArg = 0;



	unsigned long long Arg1 = GetNextArgument(&ulCurrentArg,ulArgCount, pulArgs);
	unsigned long long Arg2 = GetNextArgument(&ulCurrentArg,ulArgCount, pulArgs);
	unsigned long long Arg3 = GetNextArgument(&ulCurrentArg,ulArgCount, pulArgs);
	unsigned long long Arg4 = GetNextArgument(&ulCurrentArg,ulArgCount, pulArgs);



	if (ulArgCount > 4)
	{
		StackArguments = (unsigned long long)&pulArgs[3];
		StackCount = ulArgCount - 4;
	}




	__asm
	{
		push edi
			push esi
			X64_Start()
			push Arg1
			EMIT(0x59) //pop rcx
			push Arg2
			EMIT(0x5A) //pop rdx
			push Arg3
			EMIT(0x41) EMIT(0x58) //pop r8
			push Arg4
			EMIT(0x41) EMIT(0x59) //pop r9
			push StackArguments
			EMIT(0x5F) //pop rdi
			push StackCount
			EMIT(0x5E) //pop rsi
			test esi, esi
			jz Procedure
LoadStack:
		push [edi + (esi*8)]
		sub esi, 1
			jnz LoadStack
Procedure:
		push ucType
			EMIT(0x58)
			cmp eax, 0
			jne SysCall
			push ulAddress
			EMIT(0x58)
			sub esp, 32
			call eax
			add esp, 32
			jmp StackCleanup
SysCall:
		push Arg1
			EMIT(0x41) EMIT(0x5A) //pop r10
			mov eax, ulOrdinal
			sub esp, 40
			EMIT(0x0F) EMIT(0x05)  //syscall
			add esp, 40
StackCleanup:
		push StackCount
			EMIT(0x5E)
			test esi, esi
			jz End
Cleanup:
		pop edi
			sub esi, 1
			jnz Cleanup
End:
		mov ulNtStatus, eax
			X64_End()
			pop esi
			pop edi
	}



	return ulNtStatus;



}



__declspec(naked) unsigned long strlen64(unsigned long long Dst)
{
	__asm
	{
		push ebp
			mov ebp, esp
			xor ecx,ecx
			X64_Start()
			EMIT(0x67) EMIT(0x48) EMIT(0x8b) EMIT(0x45) EMIT (0x08) //mov rax, qword ptr[ebp+8]
Calculate:
		  
			EMIT(0x80) EMIT(0x38) EMIT (0x00) //cmp byte ptr[rax], 00
			je Done
			EMIT(0x48) EMIT(0x83) EMIT(0xC0) EMIT(0x01) //add rax, 1
			add ecx, 1
			jmp Calculate

Done:
			mov eax, ecx
			X64_End()
			mov esp, ebp
			pop ebp
			ret
	}
}


unsigned long long GetProcAddress64(unsigned long long ulModule, char *szFunction)
{

	unsigned long long ulFunction = 0;

	IMAGE_DOS_HEADER DosHeader = {0};
	IMAGE_NT_HEADERS64 NtHeaders = {0};

	memcpy64((unsigned long long)&DosHeader, ulModule, sizeof(IMAGE_DOS_HEADER));
	memcpy64((unsigned long long)&NtHeaders, ulModule + DosHeader.e_lfanew, sizeof(IMAGE_NT_HEADERS64));

	if (NtHeaders.Signature == IMAGE_NT_SIGNATURE)
	{
		char szName[256] = {0};
		IMAGE_EXPORT_DIRECTORY Exports = {0};
		unsigned long ulVA = NtHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
		unsigned long ulSize = NtHeaders.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
		unsigned long i = 0;
		memcpy64((unsigned long long)&Exports, ulModule + ulVA,sizeof(IMAGE_EXPORT_DIRECTORY));
		for(i; i < Exports.NumberOfNames; i ++)
		{
			unsigned long long ulNameOffset = 0;
			memcpy64((unsigned long long)&ulNameOffset, Exports.AddressOfNames + ulModule + (i*4),sizeof( unsigned long));
			ulNameOffset+=ulModule;
			memcpy64((unsigned long long)szName, ulNameOffset, strlen64(ulNameOffset));
			if (!m_memcmp(szFunction,szName,strlen(szFunction)))
			{
				unsigned long long ulAddressOffset = 0;
				unsigned long long ulOrdinalOffset = 0;
				memcpy64((unsigned long long)&ulOrdinalOffset, (Exports.AddressOfNameOrdinals + ulModule + (i*2)), sizeof(unsigned short));
				memcpy64((unsigned long long)&ulAddressOffset, (Exports.AddressOfFunctions + ulModule + (ulOrdinalOffset*4)), sizeof(unsigned long));
				if (ulAddressOffset > ulVA && ulAddressOffset < (ulVA + ulSize))
				{
					ulFunction = 0;
					break;
				}
				ulFunction = (ulAddressOffset+ulModule);
				break;
			}
		}

	}

	return ulFunction;
}

unsigned long SysCall64(unsigned long ulOrdinal, unsigned long long * pulArgs, unsigned long ulArgCount)
{

	unsigned long ulNtStatus = 0;
	unsigned long long StackArguments = 0;
	unsigned long long StackCount = 0;
	unsigned long ulCurrentArg = 0;



	unsigned long long Arg1 = GetNextArgument(&ulCurrentArg,ulArgCount, pulArgs);
	unsigned long long Arg2 = GetNextArgument(&ulCurrentArg,ulArgCount, pulArgs);
	unsigned long long Arg3 = GetNextArgument(&ulCurrentArg,ulArgCount, pulArgs);
	unsigned long long Arg4 = GetNextArgument(&ulCurrentArg,ulArgCount, pulArgs);



	if (ulArgCount > 4)
	{
		StackArguments = (unsigned long long)&pulArgs[3];
		StackCount = ulArgCount - 4;
	}


	__asm
	{
		push edi
			push esi
			X64_Start()

			push Arg1
			EMIT(0x59) //pop rcx
			push Arg2
			EMIT(0x5A) //pop rdx
			push Arg3
			EMIT(0x41) EMIT(0x58) //pop r8
			push Arg4
			EMIT(0x41) EMIT(0x59) //pop r9


			push StackArguments
			EMIT(0x5F) //pop rdi
			push StackCount
			EMIT(0x5E) //pop rsi

			sub esp, 40 //Stack frame spilling registers

			mov eax, esi
			imul eax, 8    
			sub esp, eax //Rest of arguments

			test esi, esi
			jz SysCall

LoadStack:
		    EMIT(0x67) EMIT(0x48) EMIT(0x8B) EMIT(0x0C) EMIT(0xF7) //mov rcx, qword ptr[edi + (esi*8)]
			EMIT(0x67) EMIT(0x48) EMIT(0x89) EMIT(0x4C) EMIT(0xF4) EMIT(0x20) //mov qword ptr [esp+(esi*8)+32], rcx
			sub esi, 1
			jnz LoadStack

SysCall:
		push Arg1
			EMIT(0x41) EMIT(0x5A) //pop r10
			mov eax, ulOrdinal
			EMIT(0x0F) EMIT(0x05)  //syscall

			push StackCount
			EMIT(0x5E) //pop rsi

			mov ulNtStatus, eax

			mov eax, esi
			imul eax, 8

			add esp, eax
			add esp, 40
End:


			X64_End()
			pop esi
			pop edi
	}


	return ulNtStatus;



}

int main()
{
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,17660);
	if (hProcess)
	{
		unsigned long long ulModule = GetModuleHandle64(L"ntdll.dll");
		if (ulModule)
		{
			unsigned long long ulNtTerminateProcess = GetProcAddress64(ulModule, "NtTerminateProcess");
		
			if (ulNtTerminateProcess)
			{
				
				DWORD64 NtCloseProc[2] = {0};
				NtCloseProc[0] = (DWORD64)hProcess;
				printf("Function Result: %2X\n", CallFunction64(ulNtTerminateProcess,0,NtCloseProc,2,0));
			}
		}
		CloseHandle(hProcess);
	}
	return 0;
}