#include "Process Dump.h"

void * DumpProcess(HANDLE hProcess, void* lpBaseAddress, unsigned long * pulSize)
{
	IMAGE_DOS_HEADER Dos = {0};
	IMAGE_NT_HEADERS Nt = {0};
	IMAGE_SECTION_HEADER Section = {0};

	unsigned long ulDiskSize = 0;
	void* lpDiskBuffer = 0;
	int i = 0;


	if (!ReadProcessMemory(hProcess,lpBaseAddress,&Dos,sizeof(IMAGE_DOS_HEADER),0))
		return 0;

	if (!ReadProcessMemory(hProcess, (void*)((unsigned long)lpBaseAddress + Dos.e_lfanew), &Nt, sizeof(IMAGE_NT_HEADERS),0))
		return 0;


	if (Nt.Signature != IMAGE_NT_SIGNATURE)
		return 0;

	if (!ReadProcessMemory(hProcess, (void*)((unsigned long)lpBaseAddress + Dos.e_lfanew + sizeof(IMAGE_NT_HEADERS) + ((Nt.FileHeader.NumberOfSections-1)*40)), &Section, sizeof(IMAGE_SECTION_HEADER),0))
		return 0;

	ulDiskSize = Section.PointerToRawData + Section.SizeOfRawData; //Size on disk, relative offset of 0.

	if (!(lpDiskBuffer = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,ulDiskSize)))
		return 0;

	if (!ReadProcessMemory(hProcess,lpBaseAddress,lpDiskBuffer,Nt.OptionalHeader.SizeOfHeaders,0))
	{
		HeapFree(GetProcessHeap(),0,lpDiskBuffer);
		return 0;
	}


	for (i; i < Nt.FileHeader.NumberOfSections;  i++)
	{
		if (!ReadProcessMemory(hProcess,  (void*)((unsigned long)lpBaseAddress + Dos.e_lfanew + sizeof(IMAGE_NT_HEADERS) + (i*40)), &Section, sizeof(IMAGE_SECTION_HEADER),0))
		{
			HeapFree(GetProcessHeap(),0,lpDiskBuffer);
			lpDiskBuffer = 0;
			break;
		}

		if (!ReadProcessMemory(hProcess, (void *)((unsigned long)lpBaseAddress + Section.VirtualAddress), (void*)((unsigned long)lpDiskBuffer +  Section.PointerToRawData), Section.Misc.VirtualSize,0))
		{
			HeapFree(GetProcessHeap(),0,lpDiskBuffer);
			lpDiskBuffer = 0;
			break;
		}


	}
	
	if (!lpDiskBuffer)
		return 0;


	*pulSize = ulDiskSize;

	return lpDiskBuffer;
}
