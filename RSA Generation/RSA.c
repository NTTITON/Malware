#include <Windows.h>
#include <stdio.h>
#include <math.h>


#define MAX 65536 //4 byte key
#define MIN 16384

/* ---EXAMPLE RSA GENERATOR BY NTTION---

Note: The encryption & decryption functions will not work accordingly, considering the data types needed have to hold more bytes since the exponents will increase the number to more than 30 digits. 
      They are there to show you how the encryption is done, the functions WILL work however if the modulus and the exponents are small. (For instance, N = 15, D = 11, P = 5, Q = 3, E = 3)

Derived equations for RSA
Let m = Message to cipher
Let n = modulus
Let d = private exponent
Let e = public exponent
Let p = prime factor of n
Let q = other prime factor of n

Rules:
1. e and d must be relatively prime to phi (n)
2. message to cipher must have char set (M) that is relatively prime to n
*/


BOOL IsPrime(unsigned long Number)
{
	unsigned long i = 2;
	for (i; i < Number; i ++)
	{
		if (Number % i == 0 )
		{
			return 0;
		}
	}
	return 1;
}

unsigned long GCD(unsigned long a, unsigned long b) 
{
	if (a < b)
	{
		unsigned long temp = a;
		a = b;
		b = temp;
	}

	while ( b > 0)
	{
		unsigned long remainder = a % b;  
		a = b;
		b = remainder;
	}
	return a;
}

double GenerateRandomNumber(unsigned long Min, unsigned long Max)
{
	return ((double)rand()/(double)RAND_MAX) *(Max - Min) + Min;
}

void GenerateModulus(unsigned long * P, unsigned long * Q)
{
	while(1)
	{
		if (!IsPrime(*P) || *P == 0|| *P == *Q )
			*P = GenerateRandomNumber(MIN,MAX);
		if (!IsPrime(*Q) || *Q == 0)
			*Q = GenerateRandomNumber(MIN,MAX);
		if (IsPrime(*P) && IsPrime(*Q) && *Q != *P)
			break;
	}
}

void GeneratePrivatePublicExponents(unsigned long *D, unsigned long*E, unsigned long P, unsigned long Q)
{
	unsigned long PHI = (P-1)*(Q-1);
	unsigned long i = 0;
	unsigned long one = 0;
	unsigned long two = 0;

/* This needs a new algorithm to find two factors that are both prime & relatively prime to PHI(N) */
/* The current algorithm Makes sure the private exponent is larger than the public exponent by a factor of X */

	while(GCD(*E, PHI) != 1)
	{
		*E = *E+1;
	}


	while((1+ (PHI*i)) % *E != 0)
	{
		i++;
	}

	*D =  (1+ (PHI*i)) / *E;
}

unsigned long FactorPrivateKey(unsigned long N, unsigned long E)
{
	unsigned long i = 2;
	unsigned long P = 0;
	unsigned long Q = 0;
	unsigned long D = 0;

	for(i; i < N; i++)
	{
		if (IsPrime(i) && N % i == 0)
		{
			Q = i;
			P = N / Q; 
			if (P != Q) 
			{
				break;
			}
		}
	}

	if (P != 0 && Q != 0)
	{
		i = 1;
		
		while ((1+ i*(P*Q - P - Q + 1)) % E != 0)
		{
			i++;
		}

		D = (1+ i*(P*Q - P - Q + 1))/E;

		printf("Private Key Factored (%lu, %lu)\n", N, D);
	}
	return D;
}





unsigned long long Power(unsigned long Base, unsigned long Exponent)
{
	unsigned long i = 0;
	unsigned long long sum = 1;
	for (i ; i< Exponent; i ++)
	{
		sum *= Base;
	}
	return sum;
}

typedef struct sASCIITable
{
	unsigned long Code;
	char Character;
}ASCIITable;


void BuildTable(unsigned long N, ASCIITable *Table)
{
	unsigned long Counter = 2;
	unsigned long i = 0;

	for(i; i < 26;i ++)
	{
		if (Counter >= N)
			break;

		while(GCD(N, Counter) != 1)
		{
			Counter++;
		}

		Table[i].Character = i+97;
		Table[i].Code = Counter++;
		
		
	}
}

unsigned long EncryptText(unsigned long N, unsigned long E, char * szText, unsigned long ulText, unsigned long *ucEncrypted)
{
	//M^E = X (mod (N))
	//Construct a table that is relatively prime to N (Up to 26 chars for english alphabet.. just for this example....
	ASCIITable Table[26] = {0};

	unsigned long i = 0;
	unsigned long EncryptedCount = 0;

	BuildTable(N, Table);
	

	for(i ;i < ulText; i ++)
	{
		unsigned char CharacterCode = *(unsigned char*)((unsigned long)szText + i);
		unsigned long X = 0;
		for(X; X < 26; X++)
		{
			if (Table[X].Character == CharacterCode)
			{
				*(unsigned long*)(ucEncrypted + i) = Power(Table[X].Code,E) % N;
				EncryptedCount++;
				break;
			}
		}
	}

	return EncryptedCount;
}

unsigned long DecryptText(unsigned long N, unsigned long D, unsigned long* ucEncrypted, unsigned long ulEncrypted, char * szBuffer)
{
	//X^D = M (mod(N))
	unsigned long i = 0;
	ASCIITable Table[26] = {0};
	BuildTable(N,Table);

	for(i; i < ulEncrypted; i ++)
	{
		unsigned long long ulCode = Power(ucEncrypted[i],D) % N;

		unsigned long X = 0;

		for (X; X < sizeof(Table); X++)
		{
			if (Table[X].Code == ulCode)
			{
				*(char*)((unsigned long)(szBuffer) + i) = Table[X].Character;
				break;
			}
		}
	}
	return ulEncrypted;
}

int main()
{
	unsigned long P = 0;
	unsigned long Q = 0;
	unsigned long D = 0;
	unsigned long E = 100;

	srand(GetTickCount()); 

	GenerateModulus(&P, &Q);
	GeneratePrivatePublicExponents(&D,&E,P,Q);

	printf("P: %lu Q: %lu\n", P, Q);
	printf("PUBLIC KEY(%lu, %lu), PRIVATE KEY(%lu, %lu)\n", P*Q, E, P*Q, D);

	printf("The private key can be factored easily, D = (1 + K(PQ - P - Q + 1) / E\n");
	FactorPrivateKey(P*Q, E);
	
	return 0;
}